C51 COMPILER V9.52.0.0   APP_2D4                                                           11/19/2017 14:57:41 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE APP_2D4
OBJECT MODULE PLACED IN .\Out\Objects\app_2d4.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\App\src\app_2d4.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Common\inc
                    -;..\App\inc;..\Bsp\inc;..\Startup;..\Bsp) DEFINE(FOSC_110592) DEBUG OBJECTEXTEND PRINT(.\Out\Listings\app_2d4.lst) TABS(
                    -2) OBJECT(.\Out\Objects\app_2d4.obj)

line level    source

   1          /*
   2           * app_2d4.c
   3           *
   4           *  Created on: 2017年8月16日
   5           *      Author: fly
   6           */
   7          
   8          #include "app.h"
   9          
  10          #define BT_MODE     0x01
  11          #define FM_MODE     0x02
  12          #define USB_MODE    0x03
  13          #define AUX_MODE    0x04
  14          #define DOME_MODE   0x05
  15          #define CALL_MODE   0x06
  16          
  17          static idata uint8_t sendRcv_flag = 0; //0 rcv， 1 send
  18          static idata uint8_t rcvBuf[PAYLOAD_WIDTH] = {0};
  19          idata uint8_t sendBuf[PAYLOAD_WIDTH] = { 0 };
  20          
  21          static char tmpBuf[16] = { 0 };
  22          
  23          void app_2d4_init(void) {
  24   1      
  25   1        sendRcv_flag = 0;
  26   1        memset(rcvBuf, 0, PAYLOAD_WIDTH);
  27   1        memset(sendBuf, 0, PAYLOAD_WIDTH);
  28   1      
  29   1        RF_Init();
  30   1        RF_RxMode();
  31   1      
  32   1      //  RF_Carrier(1);
  33   1      }
  34          
  35          void app_2d4_send(uint8_t *d, uint8_t len) {
  36   1      
  37   1        if (len > PAYLOAD_WIDTH) {
  38   2          return;
  39   2        }
  40   1      
  41   1        RF_TxMode();
  42   1        sendRcv_flag = 1;
  43   1      
  44   1        if (sendBuf != d) {
  45   2          memcpy(sendBuf, d, len);
  46   2        }
  47   1      
  48   1      }
  49          static void speaker_status_resp(void) {
  50   1        if (g_tWork.status.bits.speaker) {
  51   2          LCD_ShowString(" BAZOOKA");
  52   2        } else {
  53   2          LCD_ShowString(" PWR OFF");
C51 COMPILER V9.52.0.0   APP_2D4                                                           11/19/2017 14:57:41 PAGE 2   

  54   2        }
  55   1      }
  56          static void relay_status_resp(void) {
  57   1        if (g_tWork.status.bits.relay) {
  58   2          LCD_ShowString("ACC ON");
  59   2        } else {
  60   2          LCD_ShowString("ACC OFF");
  61   2        }
  62   1      
  63   1      }
  64          static void vol_resp(void) {
  65   1        char str[16] = { 0 };
  66   1      
  67   1      //  LCD_Clear_MHZ_ICO();
  68   1        LCD_Clear_upColon_ICO();
  69   1        LCD_Clear_downColon_ICO();
  70   1      
  71   1        sprintf(str, " VOL %u", (uint16_t) g_tWork.vol);
  72   1        LCD_ShowString(str);
  73   1      }
  74          
  75          static void clear_lcd_resp(void) {
  76   1        LCD_ShowString("        ");
  77   1      
  78   1        LCD_Clear_upColon_ICO();
  79   1        LCD_Clear_downColon_ICO();
  80   1      }
  81          static void BT_pause_show_lcd_resp(void) {
  82   1        LCD_ShowString("   PAUSE");
  83   1      }
  84          #if 0
              static void BT_play_show_lcd_resp(void) {
                LCD_ShowString("    PLAY");
              }
              static void FM_scanning_show_lcd_resp(void) {
                LCD_ShowString("SCANNING");
                LCD_Clear_upColon_ICO();
                LCD_Clear_downColon_ICO();
                LCD_Clear_MHZ_ICO();
              }
              
              static void FM_ok_show_lcd_resp(void) {
                LCD_ShowString("FM 1027 ");
                LCD_Clear_upColon_ICO();
                LCD_Show_downColon_ICO();
                LCD_Show_MHZ_ICO();
              }
              #endif
 102          static void AUX_mute_show_lcd_resp(void) {
 103   1        LCD_ShowString("   MUTE ");
 104   1      }
 105          
 106          
 107          static void USB_pause_show_lcd_resp(void) {
 108   1        LCD_ShowString("   PAUSE");
 109   1        LCD_Clear_upColon_ICO();
 110   1        LCD_Clear_downColon_ICO();
 111   1      }
 112          #if 0
              static void USB_time_show_lcd_resp(void) {
                LCD_ShowString("     349");
                LCD_Show_upColon_ICO();
C51 COMPILER V9.52.0.0   APP_2D4                                                           11/19/2017 14:57:41 PAGE 3   

                LCD_Show_downColon_ICO();
              }
              #endif
 119          static void BT_next_show_lcd_resp(void) {
 120   1        LCD_ShowString("   NEXT ");
 121   1        LCD_Clear_upColon_ICO();
 122   1        LCD_Clear_downColon_ICO();
 123   1      }
 124          static void BT_prev_show_lcd_resp(void) {
 125   1        LCD_ShowString("   PREV ");
 126   1        LCD_Clear_upColon_ICO();
 127   1        LCD_Clear_downColon_ICO();
 128   1      }
 129          static void FM_station_show_lcd_resp(void) {
 130   1        sprintf(tmpBuf, "    ST%u", (uint16_t) g_tWork.FM_station);
 131   1        LCD_ShowString(tmpBuf);
 132   1        LCD_Clear_MHZ_ICO();
 133   1        LCD_Clear_upColon_ICO();
 134   1        LCD_Show_downColon_ICO();
 135   1      }
 136          static void USB_track_show_lcd_resp(void) {
 137   1        sprintf(tmpBuf, "TR %u", g_tWork.track);
 138   1        LCD_ShowString(tmpBuf);
 139   1        LCD_Clear_upColon_ICO();
 140   1        LCD_Clear_downColon_ICO();
 141   1      }
 142          static void LED_show_blink_name_show_lcd_resp(void) {
 143   1      //  sprintf(tmpBuf, "TR %u", g_tWork.track);
 144   1        LCD_ShowString(tmpBuf);
 145   1      //  LCD_ShowString("PAUSE");
 146   1        LCD_Clear_upColon_ICO();
 147   1        LCD_Clear_downColon_ICO();
 148   1      }
 149          static void LED_clear_blink_name_show_lcd_resp(void) {
 150   1        //  sprintf(tmpBuf, "TR %u", g_tWork.track);
 151   1        LCD_ShowString("        ");
 152   1        LCD_Clear_upColon_ICO();
 153   1        LCD_Clear_downColon_ICO();
 154   1      }
 155          
 156          //static char testbuf[16] = { 0 };
 157          
 158          static void app_2d4_Rcv(uint8_t *buf) {
 159   1        uint8_t i = 0;
 160   1        uint8_t index = 0;
 161   1        uint8_t check = 0;
 162   1      
 163   1        if (buf[0] != LAMP2LCD_HEADER) {
 164   2          return;
 165   2        }
 166   1      //  key_bright_toggle();
 167   1        if (buf[1] > PAYLOAD_WIDTH) {
 168   2          return;
 169   2        }
 170   1        for (i = 0; i < (buf[1] + 1); i++) {
 171   2          check += buf[i + 1];
 172   2        }
 173   1        if (check != buf[buf[1] + 2]) {
 174   2          return;
 175   2        }
 176   1      
 177   1      //    memset(testbuf, 0, 16);
C51 COMPILER V9.52.0.0   APP_2D4                                                           11/19/2017 14:57:41 PAGE 4   

 178   1      //  sprintf(testbuf, "R%02X", (uint16_t)buf[2]);
 179   1      //  app_lcd_default_string_set(testbuf, strlen(testbuf));
 180   1      
 181   1        memset(sendBuf, 0, PAYLOAD_WIDTH);
 182   1        index = 0;
 183   1      //  switch (0) {
 184   1        switch (buf[2]) {
 185   2        case RCV_POWER_STATUS_CMD:
 186   2          Repeat_Stop();
 187   2      
 188   2          LCD_Clear_downColon_ICO();
 189   2          LCD_Clear_upColon_ICO();
 190   2      
 191   2          LCD_Clear_MHZ_ICO();
 192   2          LCD_Clear_FM_ICO();
 193   2          LCD_Clear_USB_ICO();
 194   2          LCD_Clear_AUX_ICO();
 195   2          LCD_Clear_BLUETooTH_ICO();
 196   2      
 197   2          if (buf[3] == 0x01) {
 198   3            g_tWork.status.bits.speaker = 1;
 199   3            Repeat_SetStart(speaker_status_resp);
 200   3            Repeat_SetStop(0);
 201   3            Repeat_Start(50, 1, 1);
 202   3          } else if (buf[3] == 0x02) {
 203   3            g_tWork.status.bits.speaker = 0;
 204   3            Repeat_SetStart(speaker_status_resp);
 205   3            Repeat_SetStop(0);
 206   3            Repeat_Start(20, 1, 0);
 207   3          }
 208   2          break;
 209   2        case RCV_X_BOX_STATUS_CMD:
 210   2      //    switch (buf[3]) {
 211   2      //    case BT_MODE:
 212   2      //
 213   2      //      break;
 214   2      //    case FM_MODE:
 215   2      //
 216   2      //      break;
 217   2      //    case AUX_MODE:  //AUX
 218   2      //
 219   2      //      break;
 220   2      //    case USB_MODE:  //USB
 221   2      //
 222   2      //      break;
 223   2      //    case DOME_MODE:  //LED
 224   2      //
 225   2      //      break;
 226   2      //    case CALL_MODE:
 227   2      //      break;
 228   2      //    }
 229   2      
 230   2          break;
 231   2        case RCV_BT_STATUS_CMD:
 232   2          switch (buf[3]) {
 233   3          case BT_MODE:
 234   3      //      Repeat_Stop();
 235   3            if (g_tWork.mode != BT_MODE) {
 236   4              Repeat_Stop();
 237   4              g_tWork.mode = BT_MODE;
 238   4            }
 239   3            LCD_Clear_MHZ_ICO();
C51 COMPILER V9.52.0.0   APP_2D4                                                           11/19/2017 14:57:41 PAGE 5   

 240   3            LCD_Clear_FM_ICO();
 241   3            LCD_Clear_USB_ICO();
 242   3            LCD_Clear_AUX_ICO();
 243   3      
 244   3            LCD_Show_BLUETooTH_ICO();
 245   3            if (buf[4] == 0x01) {
 246   4              sprintf(tmpBuf, " PAIRING");
 247   4            } else if (buf[4] == 0x02) {
 248   4              sprintf(tmpBuf, "  PAIRED");
 249   4            } else if (buf[4] == 0x03) {
 250   4              sprintf(tmpBuf, "TWS SCAN");
 251   4            } else if (buf[4] == 0x04) {
 252   4              sprintf(tmpBuf, "  TWS OK");
 253   4            }
 254   3            app_lcd_default_string_set(tmpBuf, strlen(tmpBuf), 0);
 255   3            break;
 256   3          case FM_MODE:
 257   3            if (buf[4] == 0x01) {
 258   4      
 259   4            } else if (buf[4] == 0x02) {
 260   4      
 261   4            } else if (buf[4] == 0x03) {
 262   4      
 263   4            } else if (buf[4] == 0x04) {
 264   4      
 265   4            }
 266   3      
 267   3            Repeat_Stop();
 268   3            LCD_Clear_All();
 269   3      
 270   3            sprintf(tmpBuf, "     %u%02u", (uint16_t) buf[3],
 271   3                (uint16_t) buf[4]);
 272   3      
 273   3      //      app_lcd_default_string_set(tmpBuf, strlen(tmpBuf));
 274   3      
 275   3            break;
 276   3          case AUX_MODE:  //AUX
 277   3      
 278   3            break;
 279   3          case USB_MODE:  //USB
 280   3      
 281   3            break;
 282   3          case DOME_MODE:  //LED
 283   3      
 284   3            break;
 285   3          case CALL_MODE:
 286   3            break;
 287   3          }
 288   2          break;
 289   2        case RCV_PLAY_PAUSE_STATUS_CMD:
 290   2          switch (buf[3]) {
 291   3          case BT_MODE:
 292   3            if (1 == buf[4]) {
 293   4              Repeat_Stop();
 294   4      
 295   4      //        Repeat_SetStart(BT_play_show_lcd_resp);
 296   4      //        Repeat_SetStop(0);
 297   4      //        Repeat_Start(20, 1, 1);
 298   4      
 299   4            } else if (2 == buf[4]) {
 300   4              Repeat_SetStart(BT_pause_show_lcd_resp);
 301   4              Repeat_SetStop(clear_lcd_resp);
C51 COMPILER V9.52.0.0   APP_2D4                                                           11/19/2017 14:57:41 PAGE 6   

 302   4              Repeat_Start(6, 6, 0);
 303   4            }
 304   3            break;
 305   3          case FM_MODE:
 306   3            if (2 == buf[4]) {
 307   4              sprintf(tmpBuf, "SCANNING");
 308   4              app_lcd_default_string_set(tmpBuf, strlen(tmpBuf), 0);
 309   4            } else if (1 == buf[4]) {
 310   4              //        Repeat_SetStart(FM_ok_show_lcd_resp);
 311   4              //        Repeat_SetStop(0);
 312   4              //        Repeat_Start(10, 1, 1);
 313   4            }
 314   3            break;
 315   3          case AUX_MODE:  //AUX
 316   3          {
 317   4            static BIT aux_pause_lock = 0;
 318   4            LCD_Clear_downColon_ICO();
 319   4            LCD_Clear_upColon_ICO();
 320   4      
 321   4            LCD_Clear_MHZ_ICO();
 322   4            LCD_Clear_FM_ICO();
 323   4            LCD_Clear_USB_ICO();
 324   4            LCD_Clear_AUX_ICO();
 325   4            LCD_Clear_BLUETooTH_ICO();
 326   4      
 327   4            LCD_Show_AUX_ICO();
 328   4            if (1 == buf[4]) {
 329   5              if (aux_pause_lock) {
 330   6                Repeat_Stop();
 331   6                aux_pause_lock = 0;
 332   6              }
 333   5              sprintf(tmpBuf, "    PLAY");
 334   5              app_lcd_default_string_set(tmpBuf, strlen(tmpBuf), 0);
 335   5            } else if (2 == buf[4]) {
 336   5              aux_pause_lock = 1;
 337   5              Repeat_SetStart(AUX_mute_show_lcd_resp);
 338   5              Repeat_SetStop(clear_lcd_resp);
 339   5              Repeat_Start(7, 7, 0);
 340   5            }
 341   4          }
 342   3            break;
 343   3          case USB_MODE:  //USB
 344   3            if (1 == buf[4]) {
 345   4              Repeat_Stop();
 346   4              //        Repeat_SetStart(USB_time_show_lcd_resp);
 347   4              //        Repeat_SetStop(0);
 348   4              //        Repeat_Start(10, 1, 1);
 349   4            } else if (2 == buf[4]) {
 350   4              Repeat_SetStart(USB_pause_show_lcd_resp);
 351   4              Repeat_SetStop(clear_lcd_resp);
 352   4              Repeat_Start(10, 10, 0);
 353   4            }
 354   3            break;
 355   3          case DOME_MODE:  //LED
 356   3            if (1 == buf[4]) { //pause
 357   4              memcpy(tmpBuf, buf + 5, 8);
 358   4              Repeat_SetStart(LED_show_blink_name_show_lcd_resp);
 359   4              Repeat_SetStop(LED_clear_blink_name_show_lcd_resp);
 360   4              Repeat_Start(6, 6, 0);
 361   4      
 362   4            } else {
 363   4              app_lcd_default_string_set(buf + 5, 8, 0);
C51 COMPILER V9.52.0.0   APP_2D4                                                           11/19/2017 14:57:41 PAGE 7   

 364   4      //        Repeat_SetStart(LED_show_blink_name_show_lcd_resp);
 365   4      //        Repeat_SetStop(0);
 366   4      //        Repeat_Start(1, 1, 1);
 367   4            }
 368   3            break;
 369   3          case CALL_MODE:
 370   3            break;
 371   3          }
 372   2      
 373   2          break;
 374   2        case RCV_PREV_NEXT_CMD:
 375   2          switch (buf[3]) {
 376   3          case BT_MODE:  //BT
 377   3            if (buf[4] == 1) { //up
 378   4              Repeat_SetStart(BT_prev_show_lcd_resp);
 379   4              Repeat_SetStop(0);
 380   4              Repeat_Start(30, 1, 1);
 381   4            } else if (buf[4] == 2) { //down
 382   4              Repeat_SetStart(BT_next_show_lcd_resp);
 383   4              Repeat_SetStop(0);
 384   4              Repeat_Start(30, 1, 1);
 385   4            }
 386   3            break;
 387   3          case FM_MODE:  //FM
 388   3            Repeat_Stop();
 389   3            g_tWork.FM_station = buf[5];
 390   3            Repeat_SetStart(FM_station_show_lcd_resp);
 391   3            Repeat_SetStop(0);
 392   3            Repeat_Start(30, 1, 1);
 393   3            break;
 394   3          case AUX_MODE:  //AUX
 395   3            break;
 396   3          case USB_MODE:  //USB
 397   3            g_tWork.track = buf[6];
 398   3            g_tWork.track |= (buf[5] << 8);
 399   3            Repeat_SetStart(USB_track_show_lcd_resp);
 400   3            Repeat_SetStop(0);
 401   3            Repeat_Start(30, 1, 1);
 402   3      
 403   3            break;
 404   3          case DOME_MODE:  //LED
 405   3            app_lcd_default_string_set(buf + 4, 8, 0);
 406   3            break;
 407   3          case CALL_MODE:
 408   3            break;
 409   3          default:
 410   3            break;
 411   3          }
 412   2          break;
 413   2        case RCV_USB_PLAY_TIME_CMD:
 414   2          if (g_tWork.mode != USB_MODE) {
 415   3            Repeat_Stop();
 416   3            g_tWork.mode = USB_MODE;
 417   3          }
 418   2          LCD_Clear_MHZ_ICO();
 419   2          LCD_Clear_FM_ICO();
 420   2          LCD_Clear_BLUETooTH_ICO();
 421   2          LCD_Clear_AUX_ICO();
 422   2      
 423   2          LCD_Show_USB_ICO();
 424   2          if (buf[3] > 9) {
 425   3            sprintf(tmpBuf, "    %u%02u", (uint16_t) buf[3], (uint16_t) buf[4]);
C51 COMPILER V9.52.0.0   APP_2D4                                                           11/19/2017 14:57:41 PAGE 8   

 426   3          } else {
 427   3            sprintf(tmpBuf, "     %u%02u", (uint16_t) buf[3],
 428   3                (uint16_t) buf[4]);
 429   3          }
 430   2          app_lcd_default_string_set(tmpBuf, strlen(tmpBuf), 3);
 431   2          break;
 432   2        case RCV_FM_HZ_CMD:
 433   2          if (g_tWork.mode != FM_MODE) {
 434   3            Repeat_Stop();
 435   3            g_tWork.mode = FM_MODE;
 436   3          }
 437   2      
 438   2          LCD_Clear_USB_ICO();
 439   2          LCD_Clear_MHZ_ICO();
 440   2          LCD_Clear_BLUETooTH_ICO();
 441   2          LCD_Clear_AUX_ICO();
 442   2      
 443   2          LCD_Show_FM_ICO();
 444   2          LCD_Show_MHZ_ICO();
 445   2      
 446   2          if (buf[3] > 99) {
 447   3            sprintf(tmpBuf, "FM %u%u", (uint16_t) buf[3], (uint16_t) buf[4]);
 448   3          } else if (buf[3] > 9) {
 449   3            sprintf(tmpBuf, "FM  %u%u", (uint16_t) buf[3], (uint16_t) buf[4]);
 450   3          } else {
 451   3            sprintf(tmpBuf, "FM   %u%u", (uint16_t) buf[3], (uint16_t) buf[4]);
 452   3          }
 453   2          app_lcd_default_string_set(tmpBuf, strlen(tmpBuf), 1);
 454   2          break;
 455   2        case RCV_VOL_CMD:
 456   2          g_tWork.vol = buf[3] & 0x7F;
 457   2          Repeat_SetStart(vol_resp);
 458   2          Repeat_SetStop(0);
 459   2          Repeat_Start(30, 1, 1);
 460   2          break;
 461   2      ////
 462   2        case KEY_POWER_SHORT_CMD:
 463   2          if (1 == buf[3]) { //pause
 464   3            memcpy(tmpBuf, buf + 4, 8);
 465   3            Repeat_SetStart(LED_show_blink_name_show_lcd_resp);
 466   3            Repeat_SetStop(LED_clear_blink_name_show_lcd_resp);
 467   3            Repeat_Start(6, 6, 0);
 468   3          } else {
 469   3            app_lcd_default_string_set(buf + 4, 8, 0);
 470   3            Repeat_SetStart(LED_show_blink_name_show_lcd_resp);
 471   3            Repeat_SetStop(0);
 472   3            Repeat_Start(1, 1, 1);
 473   3          }
 474   2          break;
 475   2        case KEY_ACC_CMD:
 476   2          LCD_Clear_downColon_ICO();
 477   2          LCD_Clear_upColon_ICO();
 478   2          if (buf[3] == 1) {
 479   3            g_tWork.status.bits.relay = 1;
 480   3          } else {
 481   3            g_tWork.status.bits.relay = 0;
 482   3          }
 483   2          Repeat_SetStart(relay_status_resp);
 484   2          Repeat_SetStop(0);
 485   2          Repeat_Start(20, 1, 1);
 486   2          break;
 487   2        case KEY_DOME_CMD:
C51 COMPILER V9.52.0.0   APP_2D4                                                           11/19/2017 14:57:41 PAGE 9   

 488   2      #if 0
                  sendBuf[index++] = LAMP2LCD_HEADER;
                  sendBuf[index++] = 11;
                  sendBuf[index++] = KEY_DOME_CMD;
                  sendBuf[index++] = g_tWork.status.bits.DOME;
                  sendBuf[index++] = g_tWork.status.bits.pause;
                  app_dome_get_current_Name(sendBuf + index, 8);
                  index += 8;
                  for (i = 0; i < (sendBuf[1] + 1); i++) {
                    sendBuf[index] += sendBuf[i + 1];
                  }
              #endif
 500   2          if (buf[3] == 1) {
 501   3            LCD_Show_LED_ICO();
 502   3            if (1 == buf[4]) { //pause
 503   4              memcpy(tmpBuf, buf + 5, 8);
 504   4              for (i = 0; i < sizeof(tmpBuf); i++) {
 505   5                if (*(tmpBuf + i) == 0) {
 506   6                  *(tmpBuf + i) = ' ';
 507   6                }
 508   5              }
 509   4              Repeat_SetStart(LED_show_blink_name_show_lcd_resp);
 510   4              Repeat_SetStop(LED_clear_blink_name_show_lcd_resp);
 511   4              Repeat_Start(5, 5, 0);
 512   4            } else {
 513   4      //        memcpy(tmpBuf, buf + 5, 8);
 514   4              app_lcd_default_string_set(buf + 5, 8, 0);
 515   4      
 516   4      //        Repeat_SetStart(LED_show_blink_name_show_lcd_resp);
 517   4      //        Repeat_SetStop(0);
 518   4      //        Repeat_Start(1, 1, 1);
 519   4            }
 520   3          } else {
 521   3            LCD_Clear_LED_ICO();
 522   3          }
 523   2          break;
 524   2        case KEY_UP_CMD:
 525   2          memcpy(tmpBuf, buf + 3, 8);
 526   2          app_lcd_default_string_set(buf + 3, 8, 0);
 527   2          Repeat_SetStart(LED_show_blink_name_show_lcd_resp);
 528   2          Repeat_SetStop(0);
 529   2          Repeat_Start(1, 1, 1);
 530   2          break;
 531   2        case KEY_DOWN_CMD:
 532   2          memcpy(tmpBuf, buf + 3, 8);
 533   2          app_lcd_default_string_set(buf + 3, 8, 0);
 534   2          Repeat_SetStart(LED_show_blink_name_show_lcd_resp);
 535   2          Repeat_SetStop(0);
 536   2          Repeat_Start(1, 1, 1);
 537   2          break;
 538   2        case MODE_CHANGE_CMD:
 539   2          LCD_Clear_MHZ_ICO();
 540   2          LCD_Clear_upColon_ICO();
 541   2          LCD_Clear_downColon_ICO();
 542   2          LCD_Clear_BLUETooTH_ICO();
 543   2          LCD_Clear_FM_ICO();
 544   2          LCD_Clear_AUX_ICO();
 545   2          LCD_Clear_USB_ICO();
 546   2      
 547   2          switch (buf[3]) {
 548   3          case BT_MODE:  //BT
 549   3            LCD_Show_BLUETooTH_ICO();
C51 COMPILER V9.52.0.0   APP_2D4                                                           11/19/2017 14:57:41 PAGE 10  

 550   3            if (1 == buf[4]) {
 551   4              strcpy(tmpBuf, "PRIRED");
 552   4            } else if (2 == buf[4]) {
 553   4              strcpy(tmpBuf, "PAIRING");
 554   4            }
 555   3            app_lcd_default_string_set(tmpBuf, strlen(tmpBuf), 0);
 556   3            break;
 557   3          case FM_MODE:  //FM
 558   3      
 559   3            break;
 560   3          case AUX_MODE:  //AUX
 561   3            LCD_Show_AUX_ICO();
 562   3            if (1 == buf[4]) {
 563   4              strcpy(tmpBuf, "PLAY");
 564   4            } else if (2 == buf[4]) {
 565   4              strcpy(tmpBuf, "MUTE");
 566   4            }
 567   3            app_lcd_default_string_set(tmpBuf, strlen(tmpBuf), 0);
 568   3            break;
 569   3          case USB_MODE:  //USB
 570   3      
 571   3            break;
 572   3          }
 573   2          break;
 574   2        }
 575   1      
 576   1        if (index) {
 577   2          index++;
 578   2      //  app_2d4_send(buf, index);
 579   2        }
 580   1      
 581   1      }
 582          
 583          void app_2d4_pro(void) {
 584   1        uint8_t i = 0;
 585   1        if (sendRcv_flag) {
 586   2          switch (ucRF_GetStatus()) {
 587   3          case TX_DS_FLAG:    // 普通型发送完成 或 增强型发送成功
 588   3      
 589   3            RF_ClearFIFO();
 590   3            RF_ClearStatus();
 591   3      
 592   3            sendRcv_flag = 0;
 593   3      
 594   3            for (i = 0; i < 100; i++) {
 595   4              nop
 596   4              nop
 597   4            }
 598   3      
 599   3            RF_RxMode();
 600   3      
 601   3            for (i = 0; i < 100; i++) {
 602   4              nop
 603   4              nop
 604   4            }
 605   3      //      key_bright_toggle();
 606   3      
 607   3            break;
 608   3          case RX_DR_FLAG:    //发送成功且收到payload
 609   3      
 610   3            RF_ClearFIFO();
 611   3            RF_ClearStatus();
C51 COMPILER V9.52.0.0   APP_2D4                                                           11/19/2017 14:57:41 PAGE 11  

 612   3            break;
 613   3          case MAX_RT_FLAG:   // 增强型发送超时失败
 614   3      
 615   3            RF_ClearFIFO();
 616   3            RF_ClearStatus();
 617   3            break;
 618   3          default:    // rf 处于空闲状态才发送数据
 619   3      
 620   3            for (i = 0; i < 130; i++) {
 621   4              nop
 622   4              nop
 623   4            }
 624   3      
 625   3            RF_TxData(sendBuf, PAYLOAD_WIDTH);
 626   3      
 627   3            break;
 628   3          }
 629   2      
 630   2        } else {
 631   2          if (ucRF_DumpRxData(rcvBuf, PAYLOAD_WIDTH)) {
 632   3      
 633   3            app_2d4_Rcv(rcvBuf);
 634   3          }
 635   2      
 636   2        }
 637   1      
 638   1      }
 639          #if 0
              void app_2d4_1S_pro(void) {
              
                switch (g_tWork.mode) {
                  case 'B':
              
                  app_lcd_default_string_set(" PAIRING", 8);
                  LCD_Clear_MHZ_ICO();
              
                  LCD_Clear_upColon_ICO();
                  LCD_Clear_downColon_ICO();
              
                  break;
                  case 'F':
                  app_lcd_default_string_set("FM  821 ", 8);
                  LCD_Clear_upColon_ICO();
                  LCD_Show_downColon_ICO();
              
                  LCD_Show_MHZ_ICO();
                  break;
                  case 'A':
                  app_lcd_default_string_set("    PLAY", 8);
                  LCD_Clear_MHZ_ICO();
                  LCD_Clear_upColon_ICO();
                  LCD_Clear_downColon_ICO();
                  break;
                  case 'U':
                  app_lcd_default_string_set("     349", 8);
                  LCD_Show_upColon_ICO();
                  LCD_Show_downColon_ICO();
              
                  LCD_Clear_MHZ_ICO();
                  break;
                }
              
C51 COMPILER V9.52.0.0   APP_2D4                                                           11/19/2017 14:57:41 PAGE 12  

              }
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3175    ----
   CONSTANT SIZE    =    246    ----
   XDATA SIZE       =     16      27
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =     33    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
